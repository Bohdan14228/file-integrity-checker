#!/bin/bash

# --- КОНФІГУРАЦІЯ ---

# Файл бази даних (DB), де зберігаються раніше обчислені хеші.
# Це ключовий елемент безпеки, його потрібно захищати.
HASH_DB=".hashes.db"

# --- ДОПОМІЖНІ ФУНКЦІЇ ---

# Нова функція: get_absolute_path
# Призначення: Перетворює наданий шлях у повний (абсолютний) шлях.
get_absolute_path() {
    local target="$1"
    
    # Використовуємо 'realpath' для отримання абсолютного шляху.
    # Це забезпечує, що база хешів завжди міститиме повний шлях, 
    # незалежно від того, звідки користувач запустив скрипт.
    realpath "$target"
}

# Функція: calculate_hashes
# Призначення: Обчислює SHA-256 хеші для наданого файлу або всіх файлів у директорії.
calculate_hashes() {
    local target="$1"
    
    # Перевіряємо, чи є вхідний аргумент директорією
    if [ -d "$target" ]; then
        # шукаємо всі файли в каталозі
        # -print0 виводить результат з нульовим байтом розподілом, щоб імена файлів з пробілами табами ... не ламали пайплайн
        find "$target" -type f -print0 | xargs -0 sha256sum | sort
    
    # Перевіряємо, чи є вхідний аргумент окремим файлом
    elif [ -f "$target" ]; then
        # Обробка одного файлу
        sha256sum "$target"
    else
        # Помилка, якщо аргумент не є ані файлом, ані директорією
        echo "Помилка: $target не є дійсним файлом чи директорією." >&2
        return 1
    fi
}

# --- ОСНОВНІ КОМАНДИ ПРОЄКТУ ---

# Команда: init (Виправлена версія: додавання/оновлення, а не перезапис)
# Призначення: Додає (або оновлює) хеші для вказаного файлу/директорії, не видаляючи інші записи.
cmd_init() {
    local input_path="$1"
    if [ -z "$input_path" ]; then
        echo "Використання: $0 init <файл/директорія>" >&2
        return 1
    fi

    local target
    target=$(get_absolute_path "$input_path")
    if [ $? -ne 0 ]; then
        echo "Помилка: Не вдалося визначити абсолютний шлях для $input_path. Перевірте, чи існує файл/директорія." >&2
        return 1
    fi

    echo "Ініціалізація або оновлення хешів для $target..."
    
    # Викликаємо calculate_hashes для нових хешів
    local new_hashes=$(calculate_hashes "$target")
    local temp_db=$(mktemp) # Створюємо тимчасовий файл
    
    # 1. Створюємо регулярний вираз для екранування шляху для grep
    local target_regex=$(echo "$target" | sed 's/[\/&]/\\&/g')

    # 2. Видаляємо старі записи, пов'язані з цим шляхом ($target), із бази даних
    # Використовуємо -v для виключення рядків, що містять $target_regex
    if [ -f "$HASH_DB" ]; then
        grep -v "$target_regex" "$HASH_DB" > "$temp_db"
    fi
    
    # 3. Додаємо нові (або оновлені) хеші до тимчасової бази даних
    echo "$new_hashes" >> "$temp_db"

    # 4. Перезаписуємо основну базу даних оновленим вмістом
    mv "$temp_db" "$HASH_DB"
    
    if [ $? -eq 0 ]; then
        echo "Хеші для $target успішно додано/оновлено у $HASH_DB."
    else
        echo "Помилка ініціалізації/оновлення." >&2
        return 1
    fi
}

# Команда: check
# Призначення: Порівнює поточні хеші з тими, що зберігаються в базі даних.
cmd_check() {
    local input_path="$1"
    if [ -z "$input_path" ]; then
        echo "Використання: $0 check <файл/директорія>" >&2
        return 1
    fi
    if [ ! -f "$HASH_DB" ]; then
        echo "Помилка: Файл бази даних хешів ($HASH_DB) не знайдено. Спочатку виконайте команду 'init'." >&2
        return 1
    fi

    # *** ДООПРАЦЮВАННЯ: Отримання абсолютного шляху ***
    local target
    target=$(get_absolute_path "$input_path")
    if [ $? -ne 0 ]; then
        echo "Помилка: Не вдалося визначити абсолютний шлях для $input_path. Перевірте, чи існує файл/директорія." >&2
        return 1
    fi
    # *************************************************

    echo "Перевірка цілісності $target..."

    # 1. Обчислюємо поточні хеші файлів, які потрібно перевірити
    local current_hashes
    current_hashes=$(calculate_hashes "$target")

    # 2. Покрокова обробка кожного рядка обчислених хешів
    while IFS= read -r line; do # IFS= - тимчасово встановлює Internal Field Separator (внутрішній розділювач Bash) у порожнє значення
        # Виділяємо хеш (перше поле)
        local current_hash=$(echo "$line" | awk '{print $1}')
        # Виділяємо шлях до файлу (всі поля, крім першого)
        # Отриманий шлях буде абсолютним, оскільки calculate_hashes використовує $target (який є абсолютним)
        local file_path=$(echo "$line" | awk '{$1=""; print $0}' | xargs)
        
        # Шукаємо відповідний старий хеш у базі даних
        local stored_hash=$(grep "$file_path" "$HASH_DB" | awk '{print $1}')
        
        # 3. Прийняття рішення та звіт про статус
        if [ -z "$stored_hash" ]; then
            # Якщо хеш не знайдено в DB
            echo "-> Файл: $file_path | Статус: НОВИЙ (не був ініціалізований)."
        elif [ "$current_hash" == "$stored_hash" ]; then
            # Якщо хеші збігаються - цілісність підтверджена
            echo "-> Файл: $file_path | Статус: ЦІЛІСНИЙ (Не змінений)."
        else
            # Якщо хеші НЕ збігаються - виявлено можливе втручання
            echo "-> Файл: $file_path | Статус: ЗМІНЕНИЙ (Невідповідність хешу: $stored_hash != $current_hash)"
        fi
    done <<< "$current_hashes" # Передаємо обчислені хеші в цикл 'while'
}

# Команда: update
# Призначення: Оновлює збережені хеші для вказаного файлу/директорії.
cmd_update() {
    local input_path="$1"
    if [ -z "$input_path" ]; then
        echo "Використання: $0 update <файл/директорія>" >&2
        return 1
    fi
    if [ ! -f "$HASH_DB" ]; then
        echo "Помилка: Файл бази даних хешів ($HASH_DB) не знайдено." >&2
        return 1
    fi
    
    # *** ДООПРАЦЮВАННЯ: Отримання абсолютного шляху ***
    local target
    target=$(get_absolute_path "$input_path")
    if [ $? -ne 0 ]; then
        echo "Помилка: Не вдалося визначити абсолютний шлях для $input_path. Перевірте, чи існує файл/директорія." >&2
        return 1
    fi
    # *************************************************

    echo "Оновлення хешів для $target..."
    local new_hashes=$(calculate_hashes "$target")
    local temp_db=$(mktemp) # Створюємо тимчасовий файл для безпечної заміни

    # Екрануємо символи (зокрема, '/') у шляху 'target', щоб використовувати його в grep
    local target_regex=$(echo "$target" | sed 's/[\/&]/\\&/g')

    # 1. Видаляємо всі старі записи, що стосуються 'target', з основної бази даних
    # grep -v '$target_regex' копіює всі рядки, які НЕ містять вказаного шляху
    grep -v "$target_regex" "$HASH_DB" > "$temp_db"
    
    # 2. Додаємо нові, свіжообчислені хеші до тимчасової бази даних
    echo "$new_hashes" >> "$temp_db"

    # 3. Атомарно замінюємо стару базу даних оновленою тимчасовою
    mv "$temp_db" "$HASH_DB"
    echo "Хеші для $target успішно оновлено."
}

# --- ГОЛОВНА ЛОГІКА СКРИПТА ---

# Читаємо перший аргумент командного рядка ($1)
case "$1" in
    init)
        # Якщо аргумент 'init', викликаємо функцію ініціалізації з другим аргументом ($2)
        cmd_init "$2"
        ;;
    check)
        # Якщо аргумент 'check', викликаємо функцію перевірки
        cmd_check "$2"
        ;;
    update)
        # Якщо аргумент 'update', викликаємо функцію оновлення
        cmd_update "$2"
        ;;
    *)
        # Якщо аргумент невідомий, показуємо довідку
        echo "Використання: $0 {init|check|update} <файл/директорія>"
        echo "  init   - Ініціалізує базу даних хешів."
        echo "  check  - Перевіряє цілісність файлів."
        echo "  update - Оновлює хеші для конкретного файлу/директорії."
        exit 1
        ;;
esac